'''Diego Garay-Ruiz, November 2023. Collection of helper functions to link amk-tools and grrm-tools, generating interactive
HTML dashboards to visualize GRRM-generated reaction networks'''

import sys
import numpy as np
import json
import networkx as nx
import bokeh.plotting
import bokeh.models as bkm
import RXVisualizer as arxviz
import networkx as nx
import argparse
from collections import Counter

def build_dashboard(G,title,outfile,size=(1400,800),
                           layout_function=nx.kamada_kawai_layout,
                           map_field="energy"):
    '''Wrapper function to generate HTML visualizations for a given network
    Input:
    - G. nx.Graph object as generated from RXReader. For profile support, it should contain a graph["pathList"] property.
    - title. String, title for the visualization.
    - outfile. String, name of the output HTML file.
    - size. Tuple of integers, size of the final visualization in pixels.
    - layout_function. Function to generate graph layout.
    - map_field. String, name of the field used for node coloring.
    Output:
    - lay. Bokeh layout as generated by full_view_layout()
    '''

    ### Define sizing
    w1 = int(size[0]*4/7)
    w2 = int(size[0]*3/7)
    wu = int(size[0]/7)
    h = int(size[1]*6/8)

    sizing_dict = {'w1':w1,'w2':w2,'wu':wu,'h':h}

    ### Define custom classes

    style_template = """
    {% block postamble %}
	<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/dgarayr/jsmol_to_bokeh/jsmol_to_bokeh.min.js"></script>
    <style>
    .bk-root .bk-btn-default {
        font-size: 1.2vh;
    }
    .bk-root .bk-input {
        font-size: 1.2vh;
        padding-bottom: 5px;
        padding-top: 5px;
    }
    .bk-root .bk {
        font-size: 1.2vh;
    }
    .bk-root .bk-clearfix{
        padding-bottom: 0.8vh;
    }
    </style>
    {% endblock %}
    """
    posx = layout_function(G)
    # Add model field to all nodes and edges & also vibrations
    arxviz.add_models(G)

    # Bokeh-powered visualization via RXVisualizer
    bk_fig,bk_graph = arxviz.bokeh_network_view(G,positions=posx,graph_title=title,width=w1,height=h,
                                                map_field=map_field,hide_energy=True)

    # bk_graph.selection_policy = bkm.NodesAndLinkedEdges()
    bk_graph.selection_policy = bkm.EdgesAndLinkedNodes()

    ### Modify the hovering tools here to add additional fields, removing the previous ones first
    valid_tools = [tool for tool in bk_fig.tools if tool.description]
    old_hovers = [tool for tool in valid_tools if "hover" in tool.description]
    for tool in old_hovers:
        bk_fig.tools.remove(tool)


    # custom edge hovering to reduce noise
    #
    hover_edgeJS = '''
    var erend = graph.edge_renderer.data_source
    var label1 = String.fromCharCode(916).concat("E1")
    var label2 = String.fromCharCode(916).concat("E2")
    if (cb_data.index.indices.length > 0) {
        var ndx = cb_data.index.indices[0]
        var tsname = erend.data["name"][ndx]
        if (tsname.includes('TSb')){
            hover.tooltips = [["tag","@name"]]
        } else {
            hover.tooltips = [["tag","@name"],["charge","@charge"],
                                ["multiplicity","@multiplicity"],["formula","@formula"],
                                [label1,"@deltaE1"],[label2,"@deltaE2"]]
        }
    }
    '''

    hover_node = bkm.HoverTool(description="Node hover",renderers=[bk_graph.node_renderer],
                               tooltips=[("tag","@name"),("charge","@charge"),("multiplicity","@multiplicity"),
                                         ("formula","@formula")],
                               formatters={"@energy":"printf"})
    bk_fig.add_tools(hover_node)
    hover_edge = bkm.HoverTool(description="Edge hover",renderers=[bk_graph.edge_renderer],
                               formatters={"@energy":"printf"},line_policy="interp")
    hover_edge.callback = bkm.CustomJS(args={"hover":hover_edge,"graph":bk_graph},code=hover_edgeJS)
    bk_fig.add_tools(hover_edge)

    highl_callback = bkm.CustomJS(args={"graph":bk_graph}, code=arxviz.js_callback_dict["highlightNeighbors"])


    lay = arxviz.full_view_layout(bk_fig,bk_graph,sizing_dict=sizing_dict)

    # add a button to the layout
    b_highlight = bkm.Button(label="Highlight neighbors",max_width=int(w1/4),align="center")
    b_highlight.js_on_click(highl_callback)


    sel_row = lay.children[0][0].children[2]
    sel_row.children = sel_row.children[0:2] + [b_highlight] + [sel_row.children[-1]]
    bokeh.plotting.output_file(outfile,title=title,mode="cdn")
    bokeh.plotting.save(lay,template=style_template)

    return lay,bk_fig,bk_graph

def scale_xyz_list(xyz,displ_vector=np.zeros(3)):
    '''Bohr-to-angstrom scaling of a list of XYZ coordinates of the form [atom, [x, y, z]].
    Input:
    - xyz. List of XYZ coordinates, containing a list [atom, [x,y,z]] with atom being a string and
    x,y,z floats.
    - displ_vector. np.Array for translating the geometry.
    Output:
    - xyz_nw. List of scaled XYZ coordinates, in the same format as the input.
    '''
    bohr_to_ang = 0.529
    xyz_arr = np.array([item[1] for item in xyz]) * bohr_to_ang + displ_vector
    xyz_nw = [[item[0],list(xyz_arr[ii])] for ii,item in enumerate(xyz)]
    return xyz_nw

def xyz_list_to_xyz_block(xyz):
    '''Transform a list of xyz coordinates [atom, [x, y, z]] into a string block.
    Input:
    - xyz. List of XYZ coordinates, containing a list [atom, [x,y,z]] with atom being a string and
    x,y,z floats.
    Output:
    - xyz_block. String, newline-joined block of the form a1,x1,y1,z2\na2,x2,y2,z2...
    '''
    xyz_block = "\n".join(["%s %.6f %.6f %.6f" % (item[0],*item[1]) for item in xyz])
    return xyz_block

def formula_from_xyz_block(xyz):
    '''Generates the molecular formula for a given XYZ geometry
    Input:
    - xyz. List of XYZ coordinates, containing a list [atom, [x,y,z]] with atom being a string and
    x,y,z floats.
    Output:
    - formula. String, molecular formula from the input geometry.
    '''
    labels = [item[0] for item in xyz]
    counter_list = sorted(Counter(labels).items())
    formula = ""
    for atom,ct in counter_list:
        if ct == 1:
            formula += atom
        else:
            formula += "%s%d" % (atom,ct)
    return formula

def sort_edge_names(edge_tuple):
    '''Helper function to sort edge tuples lexicographically.
    Input:
    - edge_tuple. Tuple with edge specification as a pair of node names.
    Output:
    - Lexicographically sorted tuple.
    '''
    n1,n2 = [int(nd) for nd in edge_tuple]
    srt_pair = sorted([n1,n2])
    return tuple([str(nd) for nd in srt_pair])

def process_graph(reaction_list,compounds,dist_adduct=3.0):
    '''Wrapper function to generate a nx.Graph from a list of reactions and a dictionary of compounds,
    including XYZ-formatted geometries where individual geometries of the species forming adducts are joined.
    Input:
    - reaction_list. List of tuples of integers of the form [n1,n2,ts] specifying the indices of nodes and transition states
    from the set of compounds to define all elementary reactions in the network.
    - compounds. Dictionary mapping node/ts indices to the different computed fields that are available -> energy, geometry,
    charge, multiplicity.
    - dist_adduct. Float, distance in angstrom between the centers of mass of adduct fragments for the
    joined 3D geometry.
    Output:
    - G. nx.Graph containing network structure and the information required by RXVisualizer module to build the final dashboard.
    '''
    bohr_to_ang = 0.529177

    G = nx.Graph()
    edge_list = [(item[0],item[1],{"tsidx":item[2]}) for item in reaction_list]
    G.add_edges_from(edge_list)
    node_renaming = {}

    ### Preprocessing compounds: for consistency, convert single elements to 1-element lists
    tgt_vars = ["energy","charge","multiplicity"]
    for comp in compounds.values():
        for vv in tgt_vars:
            if not isinstance(comp[vv],list):
                comp[vv] = [comp[vv]]

    # add node information
    for nd in G.nodes(data=True):
        comp = compounds[nd[0]]
        # nodes will be renamed to allow compounds
        # check for adducts, where both molecules must be brought together -> list of IDs
        if isinstance(comp["crn_id"],list):
            node_name = "+".join(comp["crn_id"])

            xyz_list = comp["xyz"]
            xyz0_arr = np.array([item[1] for item in xyz_list[0]]) * bohr_to_ang
            cntr = xyz0_arr.mean(axis=0)
            xyz0 = [[item[0],list(xyz0_arr[ii])] for ii,item in enumerate(xyz_list[0])]
            xyz_full = xyz0

            for ii,xyz in enumerate(xyz_list[1:]):
                displ_vec = cntr + (ii+1)*dist_adduct
                xyz_arr = np.array([item[1] for item in xyz]) * bohr_to_ang + displ_vec
                xyz_nw = [[item[0],list(xyz_arr[ii])] for ii,item in enumerate(xyz)]
                xyz_full += xyz_nw

        else:
            node_name = comp["crn_id"]
            xyz_list = [comp["xyz"]]
            # scale to angstrom
            xyz_arr = np.array([item[1] for item in xyz_list[0]]) * bohr_to_ang
            xyz_full = [[item[0],list(xyz_arr[ii])] for ii,item in enumerate(xyz_list[0])]

        node_renaming[nd[0]] = node_name
        # add this to the graph, with xyz-block format
        xyz_block = "\n".join(["%s %.6f %.6f %.6f" % (item[0],*item[1]) for item in xyz_full])
        nd[1]["geometry"] = xyz_block

        nd[1]["energy"] = sum(comp["energy"])
        nd[1]["ZPVE"] = 0.0
        nd[1]["name"] = node_name
        nd[1]["degree"] = G.degree(nd[0])
        # handle charge and multiplicity as strings to properly treat fragments
        nd[1]["charge"] = ";".join([str(item) for item in comp["charge"]])
        nd[1]["multiplicity"] = ";".join([str(item) for item in comp["multiplicity"]])
        nd[1]["formula"] = ";".join([formula_from_xyz_block(xyz) for xyz in xyz_list])
        nd[1]["neighbors"] = list(G.neighbors(nd[0]))

    for ii,ed in enumerate(G.edges(data=True)):
        e1,e2 = [sum(compounds[nd]["energy"]) for nd in ed[0:2]]
        if ed[2]["tsidx"] == "None":
            e_ts = max(e1,e2)
            ed[2]["name"] = "TSb_%04d" % ii
            ed[2]["geometry"] = None
            ed[2]["energy"] = 0.0
            ed[2]["ZPVE"] = 0.0
            delta_e1 = (e_ts - e1,ed[0])
            delta_e2 = (e_ts - e2,ed[1])
            ed[2]["deltaE1"] = "%.2f (%s)" % delta_e1
            ed[2]["deltaE2"] = "%.2f (%s)" % delta_e2
            continue
        ts_compound = compounds[ed[2]["tsidx"]]
        xyz_list = [ts_compound["xyz"]]
        geom = scale_xyz_list(xyz_list[0])
        ed[2]["geometry"] = xyz_list_to_xyz_block(geom)
        #ed[2]["name"] = "TS_%04d" % int(ed[2]["tsidx"])
        ed[2]["name"] = ts_compound["crn_id"]

        ### compute activation energy
        e_ts = sum(ts_compound["energy"])
        delta_e1 = (e_ts - e1,ed[0])
        delta_e2 = (e_ts - e2,ed[1])
        ### save string representations
        ed[2]["deltaE1"] = "%.2f (%s)" % delta_e1
        ed[2]["deltaE2"] = "%.2f (%s)" % delta_e2
        ed[2]["energy"] = sum(ts_compound["energy"])
        ed[2]["ZPVE"] = 0.0
        # handle charge and multiplicity as strings to properly treat fragments
        ed[2]["charge"] = ";".join([str(item) for item in ts_compound["charge"]])
        ed[2]["multiplicity"] = ";".join([str(item) for item in ts_compound["multiplicity"]])

        ed[2]["formula"] = ";".join([formula_from_xyz_block(xyz) for xyz in xyz_list])

    ## Apply renaming
    nx.relabel_nodes(G,node_renaming,copy=False)
    # and add neighbors now to ensure right naming
    for nd in G.nodes(data=True):
        nd[1]["neighbors"] = list(G.neighbors(nd[0]))
    return G

def read_files(reaction_file,compounds_file):
    '''Helper function to read reaction and compound files parsed from Chemoton
    Input:
    - reaction_file, compounds_file. String, names of the files to be read.
    Output:
    - reaction_tuples. List of tuples of integers of the form [n1,n2,ts] specifying the indices of nodes and transition states
    from the set of compounds to define all elementary reactions in the network.
    - compounds. Dictionary mapping node/ts indices to the different computed fields that are available -> energy, geometry,
    charge, multiplicity.
    '''
    with open(reaction_file,"r") as freac:
        reaction_tuples = [line.strip().split(",") for line in freac.readlines()]
    with open(compounds_file,"r") as fcomp:
        compounds = json.load(fcomp)

    return reaction_tuples,compounds



def main():
    parser = argparse.ArgumentParser(description="Generate Chemoton visualization")
    parser.add_argument("reaction_file",help="File specifying reactions as node1,node2,ts index integers",type=str)
    parser.add_argument("compounds_file",help="JSON file containing information about all compounds",type=str)
    g1 = parser.add_argument_group("Additional options")
    g1.add_argument("--dist_adduct",type=float,default=3.0,help="Distance between CM of adduct geometries in 3D representation")
    g1.add_argument("--output_file",type=str,default="network.html",help="Name of the output HTML file")
    g1.add_argument("--title",type=str,default="Chemoton graph",help="Title of the visualization")
    try:
        args = parser.parse_args()
    except:
        parser.print_help()
        sys.exit()
    entries,compounds = read_files(args.reaction_file,args.compounds_file)
    G = process_graph(entries,compounds,args.dist_adduct)
    build_dashboard(G,args.title,args.output_file,
                               size=(1400,800),
                               layout_function=nx.kamada_kawai_layout,
                               map_field="degree")


if __name__ == '__main__':
    main()
